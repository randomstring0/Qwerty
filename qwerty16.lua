do local name=game.Players.LocalPlayer.DisplayName;local player=game.Players.LocalPlayer;local character=player.Character;local Vector3_101=Vector3.new(1,0,1);local netless_Y=Vector3.new(0,25.1,0);local function getNetlessVelocity(realPartVelocity) local mag=realPartVelocity.Magnitude;if ((mag>1) and (mag<100)) then local unit=realPartVelocity.Unit;if ((unit.Y>0.25) or (unit.Y< -0.75)) then return realPartVelocity * (25.1/realPartVelocity.Y) ;end realPartVelocity=unit * 100 ;end return (realPartVelocity * Vector3_101) + netless_Y ;end game:GetService("StarterGui"):SetCore("SendNotification",{Title="Converted by patrick",Text="Sub @Im_Patrick On youtube to get other scripts ",Icon="rbxthumb://type=Asset&id=11774242795&w=150&h=150"});Duration=16 ; if not game:GetService("ReplicatedStorage"):FindFirstChild("01_server") then return game:GetService("TeleportService"):Teleport(17574618959, game:GetService("Players").LocalPlayer) end; local simradius="shp";local noclipAllParts=false;local antiragdoll=true;local newanimate=true;local discharscripts=true;local R15toR6=true;local hatcollide=false;local humState16=true;local addtools=false;local hedafterneck=true;local loadtime=0.5;local method=3;local alignmode=2;local flingpart="HumanoidRootPart";local lp=game:GetService("Players").LocalPlayer;local rs=game:GetService("RunService");local stepped=rs.Stepped;local heartbeat=rs.Heartbeat;local renderstepped=rs.RenderStepped;local sg=game:GetService("StarterGui");local ws=game:GetService("Workspace");local cf=CFrame.new;local v3=Vector3.new;local v3_0=Vector3.zero;local inf=math.huge;local c=lp.Character;if  not (c and c.Parent) then return;end c:GetPropertyChangedSignal("Parent"):Connect(function() if  not (c and c.Parent) then c=nil;end end);local function gp(parent,name,className) if (typeof(parent)=="Instance") then for i,v in pairs(parent:GetChildren()) do if ((v.Name==name) and v:IsA(className)) then return v;end end end return nil;end if (type(getNetlessVelocity)~="function") then getNetlessVelocity=nil;end local function align(Part0,Part1) Part0.CustomPhysicalProperties=PhysicalProperties.new(0.01,0.01,0.01,0.01,0.01);local att0=Instance.new("Attachment");att0.Orientation=v3_0;att0.Position=v3_0;att0.Name="att0_"   .. Part0.Name ;local att1=Instance.new("Attachment");att1.Orientation=v3_0;att1.Position=v3_0;att1.Name="att1_"   .. Part1.Name ;if ((alignmode==1) or (alignmode==2)) then local ape=Instance.new("AlignPosition",att0);ape.ApplyAtCenterOfMass=false;ape.MaxForce=inf;ape.MaxVelocity=inf;ape.ReactionForceEnabled=false;ape.Responsiveness=200;ape.Attachment1=att1;ape.Attachment0=att0;ape.Name="AlignPositionRtrue";ape.RigidityEnabled=true;end if ((alignmode==2) or (alignmode==3)) then local apd=Instance.new("AlignPosition",att0);apd.ApplyAtCenterOfMass=false;apd.MaxForce=inf;apd.MaxVelocity=inf;apd.ReactionForceEnabled=false;apd.Responsiveness=200;apd.Attachment1=att1;apd.Attachment0=att0;apd.Name="AlignPositionRfalse";apd.RigidityEnabled=false;end local ao=Instance.new("AlignOrientation",att0);ao.MaxAngularVelocity=inf;ao.MaxTorque=inf;ao.PrimaryAxisOnly=false;ao.ReactionTorqueEnabled=false;ao.Responsiveness=200;ao.Attachment1=att1;ao.Attachment0=att0;ao.RigidityEnabled=false;if getNetlessVelocity then local vel=Part0.Velocity;local velpart=Part1;local rsteppedcon=renderstepped:Connect(function() Part0.Velocity=vel;end);local heartbeatcon=heartbeat:Connect(function() vel=Part0.Velocity;Part0.Velocity=getNetlessVelocity(velpart.Velocity);end);local attcon=nil;Part0:GetPropertyChangedSignal("Parent"):Connect(function() if  not (Part0 and Part0.Parent) then rsteppedcon:Disconnect();heartbeatcon:Disconnect();attcon:Disconnect();end end);attcon=att1:GetPropertyChangedSignal("Parent"):Connect(function() if  not (att1 and att1.Parent) then attcon:Disconnect();velpart=Part0;else velpart=att1.Parent;if  not velpart:IsA("BasePart") then velpart=Part0;end end end);end att0.Parent=Part0;att1.Parent=Part1;end local function respawnrequest() local ccfr=ws.CurrentCamera.CFrame;local c=lp.Character;lp.Character=nil;lp.Character=c;local con=nil;con=ws.CurrentCamera.Changed:Connect(function(prop) if ((prop~="Parent") and (prop~="CFrame")) then return;end ws.CurrentCamera.CFrame=ccfr;con:Disconnect();end);end local destroyhum=(method==4) or (method==5) ;local breakjoints=(method==0) or (method==4) ;local antirespawn=(method==0) or (method==2) or (method==3) ;hatcollide=hatcollide and (method==0) ;addtools=addtools and gp(lp,"Backpack","Backpack") ;local fenv=getfenv();local shp=fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop ;local ssr=fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad ;if (shp and (simradius=="shp")) then spawn(function() while c and heartbeat:Wait()  do shp(lp,"SimulationRadius",inf);end end);elseif (ssr and (simradius=="ssr")) then spawn(function() while c and heartbeat:Wait()  do ssr(inf);end end);end antiragdoll=antiragdoll and function(v) if (v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint")) then v.Parent=nil;end end ;if antiragdoll then for i,v in pairs(c:GetDescendants()) do antiragdoll(v);end c.DescendantAdded:Connect(antiragdoll);end if antirespawn then respawnrequest();end if (method==0) then wait(loadtime);if  not c then return;end end if discharscripts then for i,v in pairs(c:GetChildren()) do if v:IsA("LocalScript") then v.Disabled=true;end end elseif newanimate then local animate=gp(c,"Animate","LocalScript");if (animate and  not animate.Disabled) then animate.Disabled=true;else newanimate=false;end end if addtools then for i,v in pairs(addtools:GetChildren()) do if v:IsA("Tool") then v.Parent=c;end end end pcall(function() settings().Physics.AllowSleep=false;settings().Physics.PhysicsEnvironmentalThrottle=Enum.EnviromentalPhysicsThrottle.Disabled;end);local OLDscripts={};for i,v in pairs(c:GetDescendants()) do if (v.ClassName=="Script") then table.insert(OLDscripts,v);end end local scriptNames={};for i,v in pairs(c:GetDescendants()) do if v:IsA("BasePart") then local newName=tostring(i);local exists=true;while exists do exists=false;for i,v in pairs(OLDscripts) do if (v.Name==newName) then exists=true;end end if exists then newName=newName   .. "_" ;end end table.insert(scriptNames,newName);Instance.new("Script",v).Name=newName;end end c.Archivable=true;local hum=c:FindFirstChildOfClass("Humanoid");if hum then for i,v in pairs(hum:GetPlayingAnimationTracks()) do v:Stop();end end local cl=c:Clone();if (hum and humState16) then hum:ChangeState(Enum.HumanoidStateType.Physics);if destroyhum then wait(1.6);end end if (hum and hum.Parent and destroyhum) then hum:Destroy();end if  not c then return;end local head=gp(c,"Head","BasePart");local torso=gp(c,"Torso","BasePart") or gp(c,"UpperTorso","BasePart") ;local root=gp(c,"HumanoidRootPart","BasePart");if (hatcollide and c:FindFirstChildOfClass("Accessory")) then local anything=c:FindFirstChildOfClass("BodyColors") or gp(c,"Health","Script") ;if  not (torso and root and anything) then return;end torso:Destroy();root:Destroy();if shp then for i,v in pairs(c:GetChildren()) do if v:IsA("Accessory") then shp(v,"BackendAccoutrementState",0);end end end anything:Destroy();end local model=Instance.new("Model",c);model.Name=model.ClassName;model:GetPropertyChangedSignal("Parent"):Connect(function() if  not (model and model.Parent) then model=nil;end end);for i,v in pairs(c:GetChildren()) do if (v~=model) then if (addtools and v:IsA("Tool")) then for i1,v1 in pairs(v:GetDescendants()) do if (v1 and v1.Parent and v1:IsA("BasePart")) then local bv=Instance.new("BodyVelocity",v1);bv.Velocity=v3_0;bv.MaxForce=v3(1000,1000,1000);bv.P=1250;bv.Name="bv_"   .. v.Name ;end end end v.Parent=model;end end if breakjoints then model:BreakJoints();else if (head and torso) then for i,v in pairs(model:GetDescendants()) do if (v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D")) then local save=false;if ((v.Part0==torso) and (v.Part1==head)) then save=true;end if ((v.Part0==head) and (v.Part1==torso)) then save=true;end if save then if hedafterneck then hedafterneck=v;end else v:Destroy();end end end end if (method==3) then spawn(function() wait(loadtime);if model then model:BreakJoints();end end);end end cl.Parent=c;for i,v in pairs(cl:GetChildren()) do v.Parent=c;end cl:Destroy();local noclipmodel=(noclipAllParts and c) or model ;local noclipcon=nil;local function uncollide() if noclipmodel then for i,v in pairs(noclipmodel:GetDescendants()) do if v:IsA("BasePart") then v.CanCollide=false;end end else noclipcon:Disconnect();end end noclipcon=stepped:Connect(uncollide);uncollide();for i,scr in pairs(model:GetDescendants()) do if ((scr.ClassName=="Script") and table.find(scriptNames,scr.Name)) then local Part0=scr.Parent;if Part0:IsA("BasePart") then for i1,scr1 in pairs(c:GetDescendants()) do if ((scr1.ClassName=="Script") and (scr1.Name==scr.Name) and  not scr1:IsDescendantOf(model)) then local Part1=scr1.Parent;if ((Part1.ClassName==Part0.ClassName) and (Part1.Name==Part0.Name)) then align(Part0,Part1);scr:Destroy();scr1:Destroy();break;end end end end end end for i,v in pairs(c:GetDescendants()) do if (v and v.Parent and  not v:IsDescendantOf(model)) then if v:IsA("Decal") then v.Transparency=1;elseif v:IsA("BasePart") then v.Transparency=1;v.Anchored=false;elseif v:IsA("ForceField") then v.Visible=false;elseif v:IsA("Sound") then v.Playing=false;elseif (v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles")) then v.Enabled=false;end end end if newanimate then local animate=gp(c,"Animate","LocalScript");if animate then animate.Disabled=false;end end if addtools then for i,v in pairs(c:GetChildren()) do if v:IsA("Tool") then v.Parent=addtools;end end end local hum0=model:FindFirstChildOfClass("Humanoid");if hum0 then hum0:GetPropertyChangedSignal("Parent"):Connect(function() if  not (hum0 and hum0.Parent) then hum0=nil;end end);end local hum1=c:FindFirstChildOfClass("Humanoid");if hum1 then hum1:GetPropertyChangedSignal("Parent"):Connect(function() if  not (hum1 and hum1.Parent) then hum1=nil;end end);ws.CurrentCamera.CameraSubject=hum1;local camSubCon=nil;local function camSubFunc() camSubCon:Disconnect();if (c and hum1) then ws.CurrentCamera.CameraSubject=hum1;end end camSubCon=renderstepped:Connect(camSubFunc);if hum0 then hum0:GetPropertyChangedSignal("Jump"):Connect(function() if hum1 then hum1.Jump=hum0.Jump;end end);else respawnrequest();end end local rb=Instance.new("BindableEvent",c);rb.Event:Connect(function() rb:Destroy();game.Players:Chat("-re");sg:SetCore("ResetButtonCallback",true);if destroyhum then c:BreakJoints();return;end if (hum0 and (hum0.Health>0)) then model:BreakJoints();hum0.Health=0;end if antirespawn then respawnrequest();end end);sg:SetCore("ResetButtonCallback",rb);spawn(function() while c do if (hum0 and hum1) then hum1.Jump=hum0.Jump;end wait();end sg:SetCore("ResetButtonCallback",true);end);R15toR6=R15toR6 and hum1 and (hum1.RigType==Enum.HumanoidRigType.R15) ;if R15toR6 then local part=gp(c,"HumanoidRootPart","BasePart") or gp(c,"UpperTorso","BasePart") or gp(c,"LowerTorso","BasePart") or gp(c,"Head","BasePart") or c:FindFirstChildWhichIsA("BasePart") ;if part then local cfr=part.CFrame;local R6parts={head={Name="Head",Size=v3(2,1,1),R15={Head=0}},torso={Name="Torso",Size=v3(2,2,1),R15={UpperTorso=0.2,LowerTorso= -0.8}},root={Name="HumanoidRootPart",Size=v3(2,2,1),R15={HumanoidRootPart=0}},leftArm={Name="Left Arm",Size=v3(1,2,1),R15={LeftHand= -0.849,LeftLowerArm= -0.174,LeftUpperArm=0.415}},rightArm={Name="Right Arm",Size=v3(1,2,1),R15={RightHand= -0.849,RightLowerArm= -0.174,RightUpperArm=0.415}},leftLeg={Name="Left Leg",Size=v3(1,2,1),R15={LeftFoot= -0.85,LeftLowerLeg= -0.29,LeftUpperLeg=0.49}},rightLeg={Name="Right Leg",Size=v3(1,2,1),R15={RightFoot= -0.85,RightLowerLeg= -0.29,RightUpperLeg=0.49}}};for i,v in pairs(c:GetChildren()) do if v:IsA("BasePart") then for i1,v1 in pairs(v:GetChildren()) do if v1:IsA("Motor6D") then v1.Part0=nil;end end end end part.Archivable=true;for i,v in pairs(R6parts) do local part=part:Clone();part:ClearAllChildren();part.Name=v.Name;part.Size=v.Size;part.CFrame=cfr;part.Anchored=false;part.Transparency=1;part.CanCollide=false;for i1,v1 in pairs(v.R15) do local R15part=gp(c,i1,"BasePart");local att=gp(R15part,"att1_"   .. i1 ,"Attachment");if R15part then local weld=Instance.new("Weld",R15part);weld.Name="Weld_"   .. i1 ;weld.Part0=part;weld.Part1=R15part;weld.C0=cf(0,v1,0);weld.C1=cf(0,0,0);R15part.Massless=true;R15part.Name="R15_"   .. i1 ;R15part.Parent=part;if att then att.Parent=part;att.Position=v3(0,v1,0);end end end part.Parent=c;R6parts[i]=part;end local R6joints={neck={Parent=R6parts.torso,Name="Neck",Part0=R6parts.torso,Part1=R6parts.head,C0=cf(0,1,0, -1,0,0,0,0,1,0,1,"-0"),C1=cf(0, -0.5,0, -1,0,0,0,0,1,0,1,"-0")},rootJoint={Parent=R6parts.root,Name="RootJoint",Part0=R6parts.root,Part1=R6parts.torso,C0=cf(0,0,0, -1,0,0,0,0,1,0,1,"-0"),C1=cf(0,0,0, -1,0,0,0,0,1,0,1,"-0")},rightShoulder={Parent=R6parts.torso,Name="Right Shoulder",Part0=R6parts.torso,Part1=R6parts.rightArm,C0=cf(1,0.5,0,0,0,1,0,1,"-0", -1,0,0),C1=cf( -0.5,0.5,0,0,0,1,0,1,"-0", -1,0,0)},leftShoulder={Parent=R6parts.torso,Name="Left Shoulder",Part0=R6parts.torso,Part1=R6parts.leftArm,C0=cf( -1,0.5,0,0,0, -1,0,1,0,1,0,0),C1=cf(0.5,0.5,0,0,0, -1,0,1,0,1,0,0)},rightHip={Parent=R6parts.torso,Name="Right Hip",Part0=R6parts.torso,Part1=R6parts.rightLeg,C0=cf(1, -1,0,0,0,1,0,1,"-0", -1,0,0),C1=cf(0.5,1,0,0,0,1,0,1,"-0", -1,0,0)},leftHip={Parent=R6parts.torso,Name="Left Hip",Part0=R6parts.torso,Part1=R6parts.leftLeg,C0=cf( -1, -1,0,0,0, -1,0,1,0,1,0,0),C1=cf( -0.5,1,0,0,0, -1,0,1,0,1,0,0)}};for i,v in pairs(R6joints) do local joint=Instance.new("Motor6D");for prop,val in pairs(v) do joint[prop]=val;end R6joints[i]=joint;end if hum1 then hum1.RigType=Enum.HumanoidRigType.R6;hum1.HipHeight=0;end end end local torso1=torso;torso=gp(c,"Torso","BasePart") or ( not R15toR6 and gp(c,torso.Name,"BasePart")) ;if ((typeof(hedafterneck)=="Instance") and head and torso and torso1) then local conNeck=nil;local conTorso=nil;local contorso1=nil;local aligns={};local function enableAligns() conNeck:Disconnect();conTorso:Disconnect();conTorso1:Disconnect();for i,v in pairs(aligns) do v.Enabled=true;end end conNeck=hedafterneck.Changed:Connect(function(prop) if table.find({"Part0","Part1","Parent"},prop) then enableAligns();end end);conTorso=torso:GetPropertyChangedSignal("Parent"):Connect(enableAligns);conTorso1=torso1:GetPropertyChangedSignal("Parent"):Connect(enableAligns);for i,v in pairs(head:GetDescendants()) do if (v:IsA("AlignPosition") or v:IsA("AlignOrientation")) then i=tostring(i);aligns[i]=v;v:GetPropertyChangedSignal("Parent"):Connect(function() aligns[i]=nil;end);v.Enabled=false;end end end local flingpart0=gp(model,flingpart,"BasePart") or gp(gp(model,flingpart,"Accessory"),"Handle","BasePart") ;local flingpart1=gp(c,flingpart,"BasePart") or gp(gp(c,flingpart,"Accessory"),"Handle","BasePart") ;local fling=function() end;if (flingpart0 and flingpart1) then flingpart0:GetPropertyChangedSignal("Parent"):Connect(function() if  not (flingpart0 and flingpart0.Parent) then flingpart0=nil;function fling() end end end);flingpart0.Archivable=true;flingpart1:GetPropertyChangedSignal("Parent"):Connect(function() if  not (flingpart1 and flingpart1.Parent) then flingpart1=nil;function fling() end end end);local att0=gp(flingpart0,"att0_"   .. flingpart0.Name ,"Attachment");local att1=gp(flingpart1,"att1_"   .. flingpart1.Name ,"Attachment");if (att0 and att1) then att0:GetPropertyChangedSignal("Parent"):Connect(function() if  not (att0 and att0.Parent) then att0=nil;function fling() end end end);att1:GetPropertyChangedSignal("Parent"):Connect(function() if  not (att1 and att1.Parent) then att1=nil;function fling() end end end);local lastfling=nil;local mouse=lp:GetMouse();function fling(target,duration,rotVelocity) if (typeof(target)=="Instance") then if target:IsA("BasePart") then target=target.Position;elseif target:IsA("Model") then target=gp(target,"HumanoidRootPart","BasePart") or gp(target,"Torso","BasePart") or gp(target,"UpperTorso","BasePart") or target:FindFirstChildWhichIsA("BasePart") ;if target then target=target.Position;else return;end elseif target:IsA("Humanoid") then local parent=target.Parent;if  not (parent and parent:IsA("Model")) then return;end target=gp(target,"HumanoidRootPart","BasePart") or gp(target,"Torso","BasePart") or gp(target,"UpperTorso","BasePart") or target:FindFirstChildWhichIsA("BasePart") ;if target then target=target.Position;else return;end else return;end elseif (typeof(target)=="CFrame") then target=target.Position;elseif (typeof(target)~="Vector3") then target=mouse.Hit;if target then target=target.Position;else return;end end lastfling=target;if (type(duration)~="number") then duration=tonumber(duration) or 0.5 ;end if (typeof(rotVelocity)~="Vector3") then rotVelocity=v3(20000,20000,20000);end if  not (target and flingpart0 and flingpart1 and att0 and att1) then return;end local flingpart=flingpart0:Clone();flingpart.Transparency=1;flingpart.Size=v3(0.01,0.01,0.01);flingpart.CanCollide=false;flingpart.Name="flingpart_"   .. flingpart0.Name ;flingpart.Anchored=true;flingpart.Velocity=v3_0;flingpart.RotVelocity=v3_0;flingpart:GetPropertyChangedSignal("Parent"):Connect(function() if  not (flingpart and flingpart.Parent) then flingpart=nil;end end);flingpart.Parent=flingpart1;if (flingpart0.Transparency>0.5) then flingpart0.Transparency=0.5;end att1.Parent=flingpart;for i,v in pairs(att0:GetChildren()) do if v:IsA("AlignOrientation") then v.Enabled=false;end end local con=nil;con=heartbeat:Connect(function() if (target and (lastfling==target) and flingpart and flingpart0 and flingpart1 and att0 and att1) then flingpart0.RotVelocity=rotVelocity;flingpart.Position=target;else con:Disconnect();end end);local rsteppedRotVel=v3(((rotVelocity.X>0) and  -1) or 1 ,((rotVelocity.Y>0) and  -1) or 1 ,((rotVelocity.Z>0) and  -1) or 1 );local con=nil;con=renderstepped:Connect(function() if (target and (lastfling==target) and flingpart and flingpart0 and flingpart1 and att0 and att1) then flingpart0.RotVelocity=rsteppedRotVel;flingpart.Position=target;else con:Disconnect();end end);wait(duration);if (lastfling~=target) then if flingpart then if (att1 and (att1.Parent==flingpart)) then att1.Parent=flingpart1;end flingpart:Destroy();end return;end target=nil;if  not (flingpart and flingpart0 and flingpart1 and att0 and att1) then return;end flingpart0.RotVelocity=v3_0;att1.Parent=flingpart1;for i,v in pairs(att0:GetChildren()) do if v:IsA("AlignOrientation") then v.Enabled=true;end end if flingpart then flingpart:Destroy();end end end end script=game:GetObjects("rbxassetid://8076428410")[1]["Animations v3"];local cmt={Angles=function(x,y,z,useRad) if  not useRad then return CFrame.Angles(x,y,z);else return CFrame.Angles(math.rad(x),math.rad(y),math.rad(z));end end};local imt={CreateWeld=function(p1,p2,c0,c1) c0,c1=c0 or CFrame.new(0,0,0) ,c1 or CFrame.new(0,0,0) ;local weld=Instance.new("Motor6D",p1);weld.Part0,weld.Part1=p1,p2;weld.C0,weld.C1=c0,c1;return weld;end,New=function(type,args) local instance=Instance.new(type);for i,v in pairs(args) do pcall(function() instance[i]=v;end);end return instance;end,Remove=function(instance,time) time=time or 0 ;game:GetService("Debris"):AddItem(instance,time);end};local math=setmetatable({random=function(minNum,maxNum,div) div=div or 1 ;return math.random(minNum * div ,maxNum * div )/div ;end},{__index=math});local CFrame=setmetatable(cmt,{__index=CFrame});local Instance=setmetatable(imt,{__index=Instance});local stepped=game:GetService("RunService").Stepped;local ins=Instance.new;local v3=Vector3.new;local cf=CFrame.new;local angles=CFrame.Angles;local rad=math.rad;local huge=math.huge;local cos=math.cos;local sin=math.sin;local tan=math.tan;local ray=Ray.new;local random=math.random;local ud=UDim.new;local ud2=UDim2.new;local c3=Color3.new;local rgb=Color3.fromRGB;local bc=BrickColor.new;local plr=game.Players.LocalPlayer;local plrg=plr.PlayerGui;local char=plr.Character;local h=char.Head;local t=char.Torso;local ra=char["Right Arm"];local la=char["Left Arm"];local rl=char["Right Leg"];local ll=char["Left Leg"];local rut=char.HumanoidRootPart;local hum=char:FindFirstChildOfClass("Humanoid");local necno=t.Neck;local rutjno=rut.RootJoint;local rsno=t["Right Shoulder"];local lsno=t["Left Shoulder"];local rhno=t["Right Hip"];local lhno=t["Left Hip"];local change=1;local sine=0;local ws=8;local jp=35;local songPos=1;local jok=false;local sprint=false;local sitting=false;local laying=false;local crying=false;local wsGrow=false;local muted=false;local anim="Idle";local asset="rbxassetid://";local songs={2734040079,1179830130,152675132,1467405749,411386717,3517565766,509308446};necc0,necc1=cf(0,t.Size.Y/2 ,0),cf(0, -h.Size.Y/2 ,0);rutjc0,rutjc1=cf(0,0,0),cf(0,0,0);rsc0,rsc1=cf(t.Size.X/2 ,t.Size.Y/4 ,0),cf( -ra.Size.X/2 ,ra.Size.Y/4 ,0);lsc0,lsc1=cf( -t.Size.X/2 ,t.Size.Y/4 ,0),cf(la.Size.X/2 ,la.Size.Y/4 ,0);rhc0,rhc1=cf(t.Size.X/4 , -t.Size.Y/2 ,0),cf(0,rl.Size.Y/2 ,0);lhc0,lhc1=cf( -t.Size.X/4 , -t.Size.Y/2 ,0),cf(0,ll.Size.Y/2 ,0);if char:FindFirstChild("Animate") then char.Animate:Destroy();end if hum:FindFirstChildOfClass("Animator") then hum.Animator:Destroy();end local nec=ins("Motor6D",t);nec.Name="Neck";nec.Part0=t;nec.Part1=h;local rutj=ins("Motor6D",rut);rutj.Name="RootJoint";rutj.Part0=t;rutj.Part1=rut;local rs=ins("Motor6D",t);rs.Name="Right Shoulder";rs.Part0=t;rs.Part1=ra;local ls=ins("Motor6D",t);ls.Name="Left Shoulder";ls.Part0=t;ls.Part1=la;local rh=ins("Motor6D",t);rh.Name="Right Hip";rh.Part0=t;rh.Part1=rl;local lh=ins("Motor6D",t);lh.Name="Left Hip";lh.Part0=t;lh.Part1=ll;necno.Parent=nil;rutjno.Parent=nil;rsno.Parent=nil;lsno.Parent=nil;rhno.Parent=nil;lhno.Parent=nil;nec.C1=necc1;nec.C0=necc0;rs.C1=rsc1;rs.C0=rsc0;ls.C1=lsc1;ls.C0=lsc0;rh.C1=rhc1;rh.C0=rhc0;lh.C1=lhc1;lh.C0=lhc0;rutj.C1=rutjc1;rutj.C0=rutjc0;local rem=Instance.New("RemoteEvent",{Name="ARemote",Parent=char});local mus=Instance.New("Sound",{Looped=true,Volume=0.5,SoundId=asset   .. songs[songPos] ,Parent=t});local vroOm=Instance.New("Sound",{Looped=true,Volume=7.5,SoundId=asset   .. 2658538628 ,Parent=t});if jok then mus:Play();end function swait() stepped:Wait();end function rayc(spos,direc,ignore,dist) return workspace:FindPartOnRayWithIgnoreList(ray(spos,direc.Unit * dist ),ignore,false,false);end function tween(instance,args,info,playOnCreate) if (instance and args) then playOnCreate=playOnCreate or true ;info=info or TweenInfo.new(1,Enum.EasingStyle.Linear,Enum.EasingDirection.In,0,false,0) ;if (typeof(info)=="table") then info=TweenInfo.new(unpack(info));end local tween=game:GetService("TweenService"):Create(instance,info,args);if playOnCreate then tween:Play();end return tween;end end mousechanger=game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(input) if (input=="leftcontrol") then sprint= not sprint;elseif (input=="n") then jok= not jok;elseif (input=="z") then sitting= not sitting;laying=false;crying=false;elseif (input=="x") then sitting=false;laying= not laying;crying=false;elseif (input=="c") then sitting=false;laying=false;crying= not crying;elseif (input=="l") then songPos=songPos + 1 ;if (songPos> #songs) then songPos=1;end mus.SoundId=asset   .. songs[songPos] ;mus:Play();mus.TimePosition=0;elseif (input=="m") then muted= not muted;end end);stepped:Connect(function() sine=sine + change ;local dir=hum.MoveDirection;if (dir.Magnitude==0) then dir=rut.Velocity/10 ;end local Ccf=rut.CFrame;local Walktest1=dir * Ccf.LookVector ;local Walktest2=dir * Ccf.RightVector ;local rotfb=Walktest1.X + Walktest1.Z ;local rotrl=Walktest2.X + Walktest2.Z ;local hit,pos,rot=rayc(rut.Position, -rut.CFrame.UpVector,{char},4.5);local verVel=rut.Velocity.y;local horVel=(rut.Velocity * v3(1,0,1)).Magnitude;if (mus.Parent~=t) then Instance.Remove(mus);mus=Instance.New("Sound",{Looped=true,Volume=0.5,SoundId=asset   .. songs[songPos] ,Parent=t});mus:Play();end if (vroOm.Parent~=t) then Instance.Remove(vroOm);vroOm=Instance.New("Sound",{Looped=true,Volume=7.5,SoundId=asset   .. 2658538628 ,Parent=t});end if (rotfb>1) then rotfb=1;elseif (rotfb< -1) then rotfb= -1;end if (rotrl>1) then rotrl=1;elseif (rotrl< -1) then rotrl= -1;end if jok then if  not sprint then ws=16;elseif  not wsGrow then ws=6;end jp=65;if  not muted then mus:Resume();else mus:Stop();end else if  not sprint then ws=8;else ws=38;end jp=35;mus:Stop();end hum.WalkSpeed=ws;hum.JumpPower=jp;local sn=0;if ((plr.Name=="vlad20020") and (random(0,1,50)==0.6)) then sn=random(5,10);end if ((anim=="walk") and hit) then if  not jok then nec.C1=nec.C1:Lerp(necc1 * cf(0,0,0) * angles(cos(sine/3 ) * 5 ,0,0,true) * angles( -rotfb/15 ,rotrl/2 ,0) ,0.2);rutj.C1=rutj.C1:Lerp(rutjc1 * cf(0,0.2 * cos(sine/3 ) ,0) * angles(sin(sine/3 ) * 2.5 ,sin(sine/6 ) * 2.5 ,0,true) * angles( -rotfb/12.5 ,0, -rotrl/8.5 ) ,0.2);rs.C1=rs.C1:Lerp(rsc1 * cf(0.05 -(0.05 * cos(sine/3 )) ,0,0.1 * cos(sine/6 ) * rotfb ) * angles( -10 -(sin(sine/6 ) * 40 * rotfb) , -sin(sine/6 ) * 25 * rotfb ,0,true) ,0.2);ls.C1=ls.C1:Lerp(lsc1 * cf( -0.05 + (0.05 * cos(sine/3 )) ,0, -0.1 * cos(sine/6 ) * rotfb ) * angles( -10 + (sin(sine/6 ) * 40 * rotfb) , -sin(sine/6 ) * 25 * rotfb ,0,true) ,0.2);rh.C1=rh.C1:Lerp(rhc1 * cf(0,0.2 * cos(sine/6 ) ,0.3 *  -cos(sine/6 ) ) * angles((7.5 * math.abs(rotfb)) + (sin(sine/6 ) * 40 * rotfb) ,sin(sine/6 ) * 5 ,sin(sine/6 ) * 40 * rotrl ,true) ,0.2);lh.C1=lh.C1:Lerp(lhc1 * cf(0, -0.2 * cos(sine/6 ) ,0.3 * cos(sine/6 ) ) * angles((7.5 * math.abs(rotfb)) -(sin(sine/6 ) * 40 * rotfb) ,sin(sine/6 ) * 5 , -sin(sine/6 ) * 40 * rotrl ,true) ,0.2);wsGrow=false;vroOm:Stop();else nec.C1=nec.C1:Lerp(necc1 * cf(0,0,0) * angles(sin(sine/5 ) * 15 ,sin(sine/10 ) * 20 ,0,true) * angles( -rotfb/10 ,rotrl/2 ,0) ,0.2);rutj.C1=rutj.C1:Lerp(rutjc1 * cf(0,cos(sine/5 ) * 2.5 ,0) * angles(0,sin(sine/10 ) * 20 ,0,true) * angles( -rotfb/5 ,0, -rotrl/5 ) ,0.2);rs.C1=rs.C1:Lerp(rsc1 * cf(0,0,sin(sine/10 ) * 2.5 * rotfb ) * angles( -15 + (sin( -sine/10 ) * 60 * rotfb) , -sin(sine/10 ) * 20 * rotfb ,0,true) ,0.2);ls.C1=ls.C1:Lerp(lsc1 * cf(0,0, -sin(sine/10 ) * 2.5 * rotfb ) * angles( -15 + (sin(sine/10 ) * 60 * rotfb) , -sin(sine/10 ) * 20 * rotfb ,0,true) ,0.2);rh.C1=rh.C1:Lerp(rhc1 * cf(sin(sine/10 ) * 2.5 * rotrl ,cos(sine/10 ) * 2.5 , -sin(sine/10 ) * 2.5 * rotfb ) * angles(6.5 -( -sin(sine/10 ) * 35 * rotfb) ,sin(sine/10 ) * 10 ,sin(sine/10 ) * 35 * rotrl ,true) ,0.2);lh.C1=lh.C1:Lerp(lhc1 * cf( -sin(sine/10 ) * 2.5 * rotrl , -cos(sine/10 ) * 2.5 ,sin(sine/10 ) * 2.5 * rotfb ) * angles(6.5 -(sin(sine/10 ) * 35 * rotfb) ,sin(sine/10 ) * 10 , -sin(sine/10 ) * 35 * rotrl ,true) ,0.2);wsGrow=false;vroOm:Stop();end elseif ((anim=="run") and hit) then if  not jok then nec.C1=nec.C1:Lerp(necc1 * cf(0,0,0) * angles(cos(sine/3 ) * 7.5 ,sin(sine/6 ) * 5 ,0,true) * angles( -rotfb/10 ,rotrl/2 ,0) ,0.2);rutj.C1=rutj.C1:Lerp(rutjc1 * cf(0,0.4 * cos(sine/3 ) ,0) * angles(sin(sine/3 ) * 4 ,sin(sine/6 ) * 7.5 ,0,true) * angles( -rotfb/5 ,0, -rotrl/5 ) ,0.2);rs.C1=rs.C1:Lerp(rsc1 * cf(0.1 -(0.1 * cos(sine/3 )) ,0, -0.15 -(0.2 * cos(sine/6 ) * rotfb) ) * angles( -15 -(sin(sine/6 ) * 110 * rotfb) , -sin(sine/6 ) * 25 * rotfb , -10,true) ,0.2);ls.C1=ls.C1:Lerp(lsc1 * cf( -0.1 + (0.1 * cos(sine/3 )) ,0, -0.15 + (0.2 * cos(sine/6 ) * rotfb) ) * angles( -15 + (sin(sine/6 ) * 110 * rotfb) , -sin(sine/6 ) * 25 * rotfb ,10,true) ,0.2);rh.C1=rh.C1:Lerp(rhc1 * cf(0,0.5 * cos(sine/6 ) ,0.75 *  -cos(sine/6 ) ) * angles((7.5 * math.abs(rotfb)) + (sin(sine/6 ) * 80 * rotfb) ,sin(sine/6 ) * 15 ,sin(sine/6 ) * 60 * rotrl ,true) ,0.2);lh.C1=lh.C1:Lerp(lhc1 * cf(0,0.5 *  -cos(sine/6 ) ,0.75 * cos(sine/6 ) ) * angles((7.5 * math.abs(rotfb)) + ( -sin(sine/6 ) * 80 * rotfb) ,sin(sine/6 ) * 15 , -sin(sine/6 ) * 60 * rotrl ,true) ,0.2);wsGrow=false;vroOm:Stop();else nec.C1=nec.C1:Lerp(necc1 * cf(0,0,0) * angles(0,0,0,true) * angles( -rotfb * 1.5 ,0,0) ,0.2);rutj.C1=rutj.C1:Lerp(rutjc1 * cf(0, -math.abs(rotfb * 1.5 ) + (1 * sin(sine)) ,0) * angles(sin(sine) * 25 ,0,cos(sine) * 15 ,true) * angles( -rotfb * 1.5 ,0, -rotrl * 1.5 ) ,0.2);rs.C1=rs.C1:Lerp(rsc1 * cf(0,0,0) * angles( -sine * 50 * (ws/750) * rotfb ,sin(sine) * 200 ,sine * 50 * (ws/750) * rotrl ,true) ,0.2);ls.C1=ls.C1:Lerp(lsc1 * cf(0,0,0) * angles( -sine * 50 * (ws/750) * rotfb ,sin(sine) * 200 ,sine * 50 * (ws/750) * rotrl ,true) ,0.2);rh.C1=rh.C1:Lerp(rhc1 * cf(0,0,1 * sin(sine/5 ) * 5 * (ws/750) ) * angles(sine * 50 * (ws/750) * rotfb ,0,sine * 50 * (ws/750) * rotrl ,true) ,0.2);lh.C1=lh.C1:Lerp(lhc1 * cf(0,0, -1 * sin(sine/5 ) * 5 * (ws/750) ) * angles(sine * 50 * (ws/750) * rotfb ,0,sine * 50 * (ws/750) * rotrl ,true) ,0.2);vroOm:Resume();if (vroOm.TimePosition>(vroOm.TimeLength-0.1)) then vroOm.TimePosition=8.5;end if (vroOm.TimePosition<0.1) then ws=6;end if (vroOm.TimePosition<8.5) then ws=ws + 0.01 ;else ws=750;wsGrow=true;end end elseif ((anim=="jump") and  not hit) then nec.C1=nec.C1:Lerp(necc1 * cf(0,0,0) * angles(0,0,0,true) ,0.2);rutj.C1=rutj.C1:Lerp(rutjc1 * cf(0,0,0) * angles(0,0,0,true) * angles( -rotfb/5 ,0, -rotrl/5 ) ,0.2);rs.C1=rs.C1:Lerp(rsc1 * cf(0,0,0) * angles(0,0,0,true) ,0.2);ls.C1=ls.C1:Lerp(lsc1 * cf(0,0,0) * angles(0,0,0,true) ,0.2);rh.C1=rh.C1:Lerp(rhc1 * cf(0,0,0) * angles(0,0,0,true) ,0.2);lh.C1=lh.C1:Lerp(lhc1 * cf(0,0,0) * angles(0,0,0,true) ,0.2);elseif ((anim=="fall") and  not hit) then nec.C1=nec.C1:Lerp(necc1 * cf(0,0,0) * angles(0,0,0,true) ,0.2);rutj.C1=rutj.C1:Lerp(rutjc1 * cf(0,0,0) * angles(0,0,0,true) * angles( -rotfb/5 ,0, -rotrl/5 ) ,0.2);rs.C1=rs.C1:Lerp(rsc1 * cf(0,0,0) * angles(sin(sine/10 ) * 5 ,cos(sine/10 ) * 5 ,0,true) ,0.2);ls.C1=ls.C1:Lerp(lsc1 * cf(0,0,0) * angles( -sin(sine/10 ) * 5 , -cos(sine/10 ) * 5 ,0,true) ,0.2);rh.C1=rh.C1:Lerp(rhc1 * cf(0,0,0) * angles(0,0,0,true) ,0.2);lh.C1=lh.C1:Lerp(lhc1 * cf(0,0,0) * angles(0,0,0,true) ,0.2);elseif ((anim=="idle") and hit) then if ( not jok or sitting or laying or crying) then nec.C1=nec.C1:Lerp(necc1 * cf(0,0,0) * angles(cos(sine/20 ) * 4 ,sin(sine/80 ) * 10 ,0,true) * angles(random( -sn,sn),random( -sn,sn),random( -sn,sn),true) ,0.2);rutj.C1=rutj.C1:Lerp(rutjc1 * cf(sin(sine/80 )/20 ,sin(sine/20 )/15 ,sin(sine/30 )/17.5 ) * angles(sin(sine/20 ) * 0.9 ,sin(sine/60 ) * 2.25 ,sin(sine/80 ) * 2.25 ,true) ,0.2);rs.C1=rs.C1:Lerp(rsc1 * cf(0,sin(sine/20 )/15 ,0) * angles(cos(sine/20 ) * 4 ,sin(sine/20 ) * 1.8 ,(sin(sine/80 ) * 2.25) + (cos(sine/20 ) * 2.25) ,true) ,0.2);ls.C1=ls.C1:Lerp(lsc1 * cf(0,sin(sine/20 )/15 ,0) * angles(cos(sine/20 ) * 4 , -sin(sine/20 ) * 1.8 ,(sin(sine/80 ) * 2.25) + ( -cos(sine/20 ) * 2.25) ,true) ,0.2);rh.C1=rh.C1:Lerp(rhc1 * cf(0,(sin(sine/20 )/15) + (sin(sine/80 )/25) ,0) * angles(((sin(sine/20 ) * 1.8) -(sin(sine/30 ) * 2.25)) + (sin(sine/60 ) * 1.35) ,sin(sine/60 ) * 2.25 ,sin(sine/80 ) * 3.25 ,true) ,0.2);lh.C1=lh.C1:Lerp(lhc1 * cf(0,(sin(sine/20 )/15) -(sin(sine/80 )/25) ,0) * angles(((sin(sine/20 ) * 1.8) -(sin(sine/30 ) * 2.25)) -(sin(sine/60 ) * 1.35) ,sin(sine/60 ) * 2.25 ,sin(sine/80 ) * 3.25 ,true) ,0.2);wsGrow=false;vroOm:Stop();elseif (jok and  not sitting and  not laying and  not crying) then nec.C1=nec.C1:Lerp(necc1 * cf(0,0,0) * angles( -cos(sine/10 ) * sin(sine/20 ) * 45 ,sin(sine/20 ) * cos(sine/40 ) * 30 ,sin(sine/30 ) * cos(sine/60 ) * 20 ,true) ,0.2);rutj.C1=rutj.C1:Lerp(rutjc1 * cf(0.25 * sin(sine/30 ) * cos(sine/60 ) , -0.65 + (1 * sin(sine/10 ) * cos(sine/20 )) ,0) * angles(sin(sine/10 ) * cos(sine/20 ) * 35 ,0,sin(sine/30 ) * cos(sine/60 ) * 10 ,true) ,0.2);rs.C1=rs.C1:Lerp(rsc1 * cf(0,0.25 -(0.25 * sin(sine/20 ) * cos(sine/10 )) ,0.25 * sin(sine/10 ) * cos(sine/20 ) ) * angles( -105 + (sin(sine/20 ) * cos(sine/10 ) * 65) ,sin(sine/20 ) * cos(sine/60 ) * 5 ,sin(sine/10 ) * cos(sine/20 ) * 70 ,true) ,0.2);ls.C1=ls.C1:Lerp(lsc1 * cf(0,0.25 -(0.25 * sin(sine/20 ) * cos(sine/10 )) ,0.25 * sin(sine/10 ) * cos(sine/20 ) ) * angles( -105 + (sin(sine/20 ) * cos(sine/10 ) * 65) ,sin(sine/20 ) * cos(sine/60 ) * 5 ,sin(sine/10 ) * cos(sine/20 ) *  -70 ,true) ,0.2);rh.C1=rh.C1:Lerp(rhc1 * cf(0, -0.625 + (1 * sin(sine/10 ) * cos(sine/20 )) ,0.25 -(0.5 * sin(sine/10 ) * cos(sine/20 )) ) * angles(10 + (sin(sine/10 ) * cos(sine/20 ) * 40) ,0,sin(sine/30 ) * cos(sine/60 ) * 17.5 ,true) ,0.2);lh.C1=lh.C1:Lerp(lhc1 * cf(0, -0.625 + (1 * sin(sine/10 ) * cos(sine/20 )) ,0.25 -(0.5 * sin(sine/10 ) * cos(sine/20 )) ) * angles(10 + (sin(sine/10 ) * cos(sine/20 ) * 40) ,0,sin(sine/30 ) * cos(sine/60 ) * 17.5 ,true) ,0.2);wsGrow=false;vroOm:Stop();end end if (verVel>20) then anim="jump";change=1;nec.C0=nec.C0:Lerp(necc0 * cf(0,0,0) * angles(5,0,0,true) ,0.2);rutj.C0=rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles( -5,0,0,true) ,0.2);rs.C0=rs.C0:Lerp(rsc0 * cf(0, -0.15, -0.25) * angles(150,10,12.5,true) ,0.2);ls.C0=ls.C0:Lerp(lsc0 * cf(0, -0.15, -0.25) * angles(155, -10, -12.5,true) ,0.2);rh.C0=rh.C0:Lerp(rhc0 * cf(0,0.5, -0.35) * angles( -12.5,0,5,true) ,0.2);lh.C0=lh.C0:Lerp(lhc0 * cf(0,0.2, -0.15) * angles( -2.5,0, -5,true) ,0.2);elseif (verVel< -20) then anim="fall";change=1;nec.C0=nec.C0:Lerp(necc0 * cf(0,0,0) * angles( -7.5,0,0,true) ,0.2);rutj.C0=rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(5,0,0,true) ,0.2);rs.C0=rs.C0:Lerp(rsc0 * cf(0.25, -0.25,0) * angles(0,10,110,true) ,0.2);ls.C0=ls.C0:Lerp(lsc0 * cf( -0.25, -0.25,0) * angles(0, -10, -110,true) ,0.2);rh.C0=rh.C0:Lerp(rhc0 * cf(0,0.2, -0.15) * angles( -2.5,0,5,true) ,0.2);lh.C0=lh.C0:Lerp(lhc0 * cf(0,0.5, -0.35) * angles( -12.5,0, -5,true) ,0.2);elseif ((horVel>5) and (verVel> -20) and (verVel<20)) then if  not sprint then anim="walk";if  not jok then change=0.6;else change=1;end nec.C0=nec.C0:Lerp(necc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);rutj.C0=rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);rs.C0=rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);ls.C0=ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);rh.C0=rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);lh.C0=lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);else anim="run";if  not jok then change=0.9;else change=1;end nec.C0=nec.C0:Lerp(necc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);rutj.C0=rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);rs.C0=rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);ls.C0=ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);rh.C0=rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);lh.C0=lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);end elseif ((horVel<5) and (verVel> -20) and (verVel<20)) then anim="idle";change=1;if ( not sitting and  not laying and  not crying) then if  not jok then nec.C0=nec.C0:Lerp(necc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);rutj.C0=rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);rs.C0=rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(0.5,0, -0.5,true) ,0.2);ls.C0=ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(0.5,0,0.5,true) ,0.2);rh.C0=rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(0, -2.5,2,true) ,0.2);lh.C0=lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(0,2.5, -2,true) ,0.2);else nec.C0=nec.C0:Lerp(necc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);rutj.C0=rutj.C0:Lerp(rutjc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);rs.C0=rs.C0:Lerp(rsc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);ls.C0=ls.C0:Lerp(lsc0 * cf(0,0,0) * angles(0,0,0,true) ,0.2);rh.C0=rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(0,0,5,true) ,0.2);lh.C0=lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(0,0, -5,true) ,0.2);end elseif (sitting and  not laying and  not crying) then nec.C0=nec.C0:Lerp(necc0 * cf(0,0,0) * angles( -20,0,0,true) ,0.2);rutj.C0=rutj.C0:Lerp(rutjc0 * cf(0,1.75,0) * angles( -15,0,0,true) ,0.2);rs.C0=rs.C0:Lerp(rsc0 * cf( -0.1, -0.5,0.15) * angles( -20, -60,10,true) ,0.2);ls.C0=ls.C0:Lerp(lsc0 * cf(0, -0.25, -0.2) * angles(70, -60,60,true) * angles(40,0,0,true) ,0.2);rh.C0=rh.C0:Lerp(rhc0 * cf(0,0,0) * angles(70,7.5,5,true) ,0.2);lh.C0=lh.C0:Lerp(lhc0 * cf(0,1.25, -0.5) * angles(10, -10, -5,true) ,0.2);elseif ( not sitting and laying and  not crying) then nec.C0=nec.C0:Lerp(necc0 * cf(0,0,0) * angles( -35,0,0,true) ,0.2);rutj.C0=rutj.C0:Lerp(rutjc0 * cf(0,0, -2.4) * angles( -87.5,0,0,true) ,0.2);rs.C0=rs.C0:Lerp(rsc0 * cf( -0.1,0.75, -0.25) * angles(195,0, -65,true) * angles(0,90,0,true) ,0.2);ls.C0=ls.C0:Lerp(lsc0 * cf(0.125, -0.3, -0.05) * angles(90,20,85,true) * angles( -30,20,0,true) ,0.2);rh.C0=rh.C0:Lerp(rhc0 * cf(0,0.25, -1) * angles( -55,20,7.5,true) ,0.2);lh.C0=lh.C0:Lerp(lhc0 * cf(0,0,0) * angles(2, -7.5,5,true) ,0.2);elseif ( not sitting and  not laying and crying) then nec.C0=nec.C0:Lerp(necc0 * cf(0,0,0) * angles( -80,0,0,true) ,0.2);rutj.C0=rutj.C0:Lerp(rutjc0 * cf(0,1.9,0) * angles(10,0,0,true) ,0.2);rs.C0=rs.C0:Lerp(rsc0 * cf( -0.25, -0.475, -0.8) * angles(85,0, -80,true) * angles(0,100,0,true) ,0.2);ls.C0=ls.C0:Lerp(lsc0 * cf(0.25, -0.4, -0.75) * angles(80,0,85,true) * angles(0, -87.5,0,true) ,0.2);rh.C0=rh.C0:Lerp(rhc0 * cf(0,1.85, -0.75) * angles(5, -5, -5,true) ,0.2);lh.C0=lh.C0:Lerp(lhc0 * cf(0,1.85, -0.7) * angles(3.5,5,5,true) ,0.2);end end end); end
